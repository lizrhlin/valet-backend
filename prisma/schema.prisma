// Schema Prisma para Aplicativo Liz (Valet)
// Sistema de serviços domésticos - Conecta clientes a profissionais

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL")
}

// ============================================
// ENUMS
// ============================================

enum UserType {
  CLIENT       // Cliente que contrata serviços
  PROFESSIONAL // Profissional que presta serviços
  ADMIN        // Administrador do sistema
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING_VERIFICATION
}

enum AppointmentStatus {
  PENDING     // Aguardando confirmação do profissional
  CONFIRMED   // Confirmado pelo profissional
  ON_WAY      // Profissional a caminho
  IN_PROGRESS // Serviço em andamento
  COMPLETED   // Serviço finalizado
  CANCELLED   // Cancelado
  REJECTED    // Rejeitado pelo profissional
}

enum PaymentMethod {
  CASH
  CARD
  PIX
}

enum PaymentStatus {
  PENDING
  PAID
  REFUNDED
}

enum NotificationType {
  INFO
  SUCCESS
  WARNING
  ERROR
  BOOKING    // Notificações de agendamento
  REVIEW     // Notificações de avaliações
  SYSTEM     // Notificações do sistema
}

enum ReviewRole {
  CLIENT
  PROFESSIONAL
}

// ============================================
// USUÁRIOS
// ============================================

model User {
  id        String     @id @default(cuid())
  email     String     @unique
  name      String
  phone     String?
  passwordHash  String  @map("password")  // Bcrypt hash da senha
  avatar    String?    // URL da foto de perfil
  userType  UserType   @default(CLIENT)
  status    UserStatus @default(PENDING_VERIFICATION)
  
  // Documentos para verificação
  cpf              String?
  verificationDocs String[] // URLs dos documentos

  // Preferências
  notificationsEnabled Boolean @default(true)
  language             String  @default("pt-BR")

  // Tokens (NUNCA armazenar tokens puros, apenas hashes)
  refreshTokenHash      String?  @map("refreshToken")  // Hash SHA256 do refresh token
  resetPasswordToken String?
  resetPasswordExpires DateTime?

  // ===== CAMPOS ESPECÍFICOS DE PROFISSIONAIS (NULL para clientes) =====
  specialty        String?  // Especialização principal
  description      String?  @db.Text
  experience       String?  // Ex: "5 anos", "Iniciante"
  servicesCompleted Int     @default(0) @map("services_completed")
  
  // Disponibilidade do profissional
  available   Boolean @default(false)
  isVerified  Boolean @default(false) @map("is_verified")
  
  // Localização do profissional
  location    String?
  latitude    Float?
  longitude   Float?
  
  // Avaliações (calculados)
  rating       Float @default(0)
  reviewCount  Int   @default(0) @map("review_count")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relacionamentos
  addresses       Address[]
  
  // Como cliente
  appointmentsAsClient Appointment[] @relation("ClientAppointments")
  favorites            Favorite[] @relation("FavoritesUser")
  
  // Como profissional
  appointmentsAsProfessional Appointment[] @relation("ProfessionalAppointments")
  categories                 ProfessionalCategory[] @relation("ProfessionalCategories")
  subcategories              ProfessionalSubcategory[] @relation("ProfessionalSubcategories")
  availability               Availability[]
  customAvailability         CustomAvailability[] @relation("CustomAvailability")
  favoritedBy                Favorite[] @relation("FavoritesProfessional")
  
  // Reviews (unificado)
  reviewsGiven    Review[] @relation("ReviewsGiven")
  reviewsReceived Review[] @relation("ReviewsReceived")
  
  // Notificações
  notifications   Notification[]

  @@map("users")
  @@unique([cpf, userType], name: "unique_cpf_usertype")
  @@index([email])
  @@index([userType])
  @@index([status])
  @@index([location])
  @@index([available])
}

// ============================================
// CATEGORIAS E SERVIÇOS
// ============================================

model Category {
  id              Int      @id @default(autoincrement())
  name            String   @unique
  slug            String   @unique
  icon            String
  backgroundColor String
  description     String?
  isActive        Boolean  @default(true)
  order           Int      @default(0) // Para ordenação na UI

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subcategories       Subcategory[]
  professionalCategories ProfessionalCategory[]

  @@map("categories")
  @@index([slug])
  @@index([isActive])
}

model Subcategory {
  id          Int      @id @default(autoincrement())
  categoryId  Int
  category    Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  name        String
  slug        String   @unique
  description String?  @db.Text
  
  // Preços sugeridos (podem variar por profissional)
  suggestedMinPrice Float?
  suggestedMaxPrice Float?
  
  // Tempo estimado em minutos
  estimatedDuration Int?
  
  // Imagem do serviço
  imageUrl    String?
  
  isActive    Boolean @default(true)
  order       Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  professionalSubcategories ProfessionalSubcategory[]
  appointments             Appointment[]

  @@map("subcategories")
  @@index([categoryId])
  @@index([slug])
  @@index([isActive])
}

// Relacionamento N:N entre Profissional (User) e Categoria
model ProfessionalCategory {
  id             String   @id @default(cuid())
  professionalId String   @map("professional_id")
  professional   User     @relation(fields: [professionalId], references: [id], onDelete: Cascade, name: "ProfessionalCategories")
  categoryId     Int      @map("category_id")
  category       Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([professionalId, categoryId])
  @@map("professional_categories")
  @@index([professionalId])
  @@index([categoryId])
}

// Relacionamento N:N entre Profissional (User) e Subcategoria (com preço)
model ProfessionalSubcategory {
  id             String      @id @default(cuid())
  professionalId String      @map("professional_id")
  professional   User        @relation(fields: [professionalId], references: [id], onDelete: Cascade, name: "ProfessionalSubcategories")
  subcategoryId  Int         @map("subcategory_id")
  subcategory    Subcategory @relation(fields: [subcategoryId], references: [id], onDelete: Cascade)
  
  // Preço específico deste profissional para este serviço
  price       Float
  description String? // Descrição personalizada do profissional
  
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([professionalId, subcategoryId])
  @@map("professional_subcategories")
  @@index([professionalId])
  @@index([subcategoryId])
  @@index([isActive])
}

// ============================================
// ENDEREÇOS
// ============================================

model Address {
  id           String  @id @default(cuid())
  userId       String  @map("user_id")
  user         User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  street       String
  number       String
  complement   String?
  neighborhood String
  city         String
  state        String
  zipCode      String
  
  // Coordenadas para cálculo de distância
  latitude     Float?
  longitude    Float?
  
  isDefault Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  appointments Appointment[]

  @@map("addresses")
  @@index([userId])
  @@index([isDefault])
}

// ============================================
// AGENDAMENTOS
// ============================================

model Appointment {
  id            String            @id @default(cuid())
  orderNumber   String            @unique // Número do pedido visível
  
  // Relacionamentos
  clientId      String            @map("client_id")
  client        User              @relation("ClientAppointments", fields: [clientId], references: [id], map: "fk_appointments_client")
  
  professionalId String           @map("professional_id")
  professional   User             @relation("ProfessionalAppointments", fields: [professionalId], references: [id], map: "fk_appointments_professional")
  
  subcategoryId Int               @map("subcategory_id")
  subcategory   Subcategory       @relation(fields: [subcategoryId], references: [id])
  
  addressId     String            @map("address_id")
  address       Address           @relation(fields: [addressId], references: [id])
  
  // Detalhes do agendamento
  scheduledDate DateTime
  scheduledTime String            // Ex: "14:00"
  
  estimatedDuration Int?          // Em minutos
  actualDuration    Int?          // Em minutos (após conclusão)
  
  status AppointmentStatus @default(PENDING)
  
  // Valores
  price          Float
  paymentMethod  PaymentMethod?
  paymentStatus  PaymentStatus  @default(PENDING)
  
  // Observações
  notes          String?        @db.Text
  cancellationReason String?    @db.Text
  
  // Timestamps importantes
  confirmedAt  DateTime?
  startedAt    DateTime?
  completedAt  DateTime?
  cancelledAt  DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relacionamentos
  reviews  Review[]

  @@map("appointments")
  @@index([clientId])
  @@index([professionalId])
  @@index([subcategoryId])
  @@index([status])
  @@index([scheduledDate])
  @@index([orderNumber])
}

// ============================================
// AVALIAÇÕES
// ============================================

model Review {
  id             String      @id @default(cuid())
  
  // Relacionamento com agendamento
  appointmentId  String      @map("appointment_id")
  appointment    Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade, map: "fk_reviews_appointment")
  
  // Quem avaliou (FROM)
  fromUserId     String      @map("from_user_id")
  fromUser       User        @relation("ReviewsGiven", fields: [fromUserId], references: [id], map: "fk_reviews_from_user")
  roleFrom       ReviewRole  // CLIENT ou PROFESSIONAL
  
  // Quem foi avaliado (TO)
  toUserId       String      @map("to_user_id")
  toUser         User        @relation("ReviewsReceived", fields: [toUserId], references: [id], map: "fk_reviews_to_user")
  roleTo         ReviewRole  // CLIENT ou PROFESSIONAL
  
  // Avaliação
  rating         Int         // 1-5 estrelas
  comment        String?     @db.Text
  
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  @@map("reviews")
  @@unique([appointmentId, fromUserId]) // Cada user avalia o appointment 1x
  @@index([toUserId])
  @@index([fromUserId])
  @@index([rating])
}

// ============================================
// FAVORITOS
// ============================================

model Favorite {
  id             String @id @default(cuid())
  
  userId         String @map("user_id")
  user           User   @relation("FavoritesUser", fields: [userId], references: [id], onDelete: Cascade, map: "fk_favorites_user")
  
  professionalId String @map("professional_id")
  professional   User   @relation("FavoritesProfessional", fields: [professionalId], references: [id], onDelete: Cascade, map: "fk_favorites_professional")
  
  createdAt DateTime @default(now())

  @@unique([userId, professionalId])
  @@map("favorites")
  @@index([userId])
  @@index([professionalId])
}

// ============================================
// NOTIFICAÇÕES
// ============================================

model Notification {
  id      String           @id @default(cuid())
  userId  String           @map("user_id")
  user    User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type    NotificationType
  title   String
  message String           @db.Text
  
  // Dados adicionais em JSON
  data    Json?
  
  isRead  Boolean          @default(false)
  
  createdAt DateTime @default(now())

  @@map("notifications")
  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@index([createdAt])
}

// ============================================
// DISPONIBILIDADE DO PROFISSIONAL
// ============================================

model Availability {
  id             String @id @default(cuid())
  professionalId String @map("professional_id")
  professional   User   @relation(fields: [professionalId], references: [id], onDelete: Cascade)
  
  // Dia da semana (0 = Domingo, 6 = Sábado)
  dayOfWeek Int
  
  // Horários disponíveis
  startTime String // Ex: "08:00"
  endTime   String // Ex: "18:00"
  
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("availability")
  @@index([professionalId])
  @@index([dayOfWeek])
  @@index([isActive])
}

// Disponibilidade específica por data (sobrescreve a disponibilidade semanal)
model CustomAvailability {
  id             String @id @default(cuid())
  professionalId String @map("professional_id")
  professional   User   @relation("CustomAvailability", fields: [professionalId], references: [id], onDelete: Cascade)
  
  // Data específica
  date DateTime @db.Date
  
  // Horário específico
  timeSlot String // Ex: "08:00", "08:30", etc.
  
  isAvailable Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("custom_availability")
  @@unique([professionalId, date, timeSlot])
  @@index([professionalId])
  @@index([date])
}
